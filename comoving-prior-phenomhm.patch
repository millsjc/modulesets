From c7b76d385ddff11208b77438d360c43e50dfbdb1 Mon Sep 17 00:00:00 2001
From: Cameron Mills <joseph.mills@ligo.org>
Date: Sun, 28 Oct 2018 14:00:00 +0000
Subject: [PATCH] added uniform in comoing volume prior and ability to sample
 in redshift and source-frame masses. See
 https://git.ligo.org/lscsoft/lalsuite/merge_requests/528

---
 lal/src/tools/LALCosmologyCalculator.c           | 54 ++++++++++++++-
 lal/src/tools/LALCosmologyCalculator.h           |  1 +
 lalinference/python/lalinference/bayespputils.py | 32 ++++++---
 lalinference/src/LALInference.c                  |  8 ++-
 lalinference/src/LALInference.h                  |  2 +
 lalinference/src/LALInferenceInitCBC.c           | 85 ++++++++++++++++++------
 lalinference/src/LALInferenceLikelihood.c        | 15 ++++-
 lalinference/src/LALInferenceNestedSampler.c     | 15 +++++
 lalinference/src/LALInferencePrior.c             | 83 +++++++++++++++--------
 lalinference/src/LALInferenceProposal.c          | 12 +++-
 lalinference/src/LALInferenceReadData.c          |  1 +
 lalinference/src/LALInferenceReadData.h          |  3 +-
 lalinference/src/LALInferenceTemplate.c          | 60 ++++++++++++++++-
 13 files changed, 305 insertions(+), 66 deletions(-)

diff --git a/lal/src/tools/LALCosmologyCalculator.c b/lal/src/tools/LALCosmologyCalculator.c
index 6c9d7dec29..7dd06aa107 100644
--- a/lal/src/tools/LALCosmologyCalculator.c
+++ b/lal/src/tools/LALCosmologyCalculator.c
@@ -17,7 +17,9 @@
  */
 #include <lal/LALMalloc.h>
 #include <lal/LALCosmologyCalculator.h>
-
+#include <gsl/gsl_errno.h>
+#include <gsl/gsl_math.h>
+#include <gsl/gsl_roots.h>
 /**
  * The set of functions in this module implements the standard cosmological distance measures
  * defined a Friedmann-Robertson-Walker-Lemaitre metric.
@@ -471,3 +473,53 @@ void XLALSetCosmologicalRateParametersDefaultValue(LALCosmologicalRateParameters
     params->Q= 0.0;
     params->R= 0.0;
 }
+
+struct dl2red {
+  LALCosmologicalParameters *omega; 
+  double dl; 
+  };
+  
+static double FindDistZeros(double z,void *params)
+{
+  struct dl2red * tparams = (struct dl2red *)params;
+  LALCosmologicalParameters *omega = (tparams->omega);
+  double dl = (tparams->dl);
+  return (dl-XLALLuminosityDistance(omega, z));
+  }
+
+double XLALRedshiftFromLuminosityDistance(LALCosmologicalParameters *omega,double dl, double zmin,double zmax){  
+  /*
+   * Convert luminosity distance to redshift for a given cosmology
+   * */
+  const gsl_root_fsolver_type * T  = gsl_root_fsolver_bisection;
+  gsl_root_fsolver * s  = gsl_root_fsolver_alloc (T);
+  gsl_function F;
+  double r = 0;
+  double x_lo = 0.0, x_hi = 5.0;
+  struct dl2red params = { omega, dl};
+  F.function = &FindDistZeros;
+  F.params = &params;
+  gsl_root_fsolver_set (s, &F,zmin,zmax);
+  int max_iter=1000;
+  int iter=0;
+  int status;
+  do
+    {
+      iter++;
+      status = gsl_root_fsolver_iterate (s);
+      r = gsl_root_fsolver_root (s);
+      x_lo = gsl_root_fsolver_x_lower (s);
+      x_hi = gsl_root_fsolver_x_upper (s);
+      status = gsl_root_test_interval (x_lo, x_hi,
+                                       0, 0.001);
+    }
+  while (status == GSL_CONTINUE && iter < max_iter);
+
+  gsl_root_fsolver_free (s);
+  if (iter == max_iter){
+    fprintf(stderr,"WARNING, could not succesfully calculate redshift for distance %lf\n",dl);
+    }
+  return r;
+  
+  }
+
diff --git a/lal/src/tools/LALCosmologyCalculator.h b/lal/src/tools/LALCosmologyCalculator.h
index 5a45163a51..00c52b2c0b 100644
--- a/lal/src/tools/LALCosmologyCalculator.h
+++ b/lal/src/tools/LALCosmologyCalculator.h
@@ -127,5 +127,6 @@ double XLALRateWeightedComovingVolumeDistribution(LALCosmologicalParametersAndRa
 LALCosmologicalParametersAndRate *XLALCreateCosmologicalParametersAndRate(void);
 void XLALDestroyCosmologicalParametersAndRate(LALCosmologicalParametersAndRate *p);
 void XLALSetCosmologicalRateParametersDefaultValue(LALCosmologicalRateParameters *params);
+double XLALRedshiftFromLuminosityDistance(LALCosmologicalParameters *omega,double dl, double zmin,double zmax);
 #endif
 
diff --git a/lalinference/python/lalinference/bayespputils.py b/lalinference/python/lalinference/bayespputils.py
index c943e1975d..7e1024b9ea 100644
--- a/lalinference/python/lalinference/bayespputils.py
+++ b/lalinference/python/lalinference/bayespputils.py
@@ -781,6 +781,7 @@ class Posterior(object):
         self._injXMLFuncMap={
                             'mchirp':lambda inj:inj.mchirp,
                             'chirpmass':lambda inj:inj.mchirp,
+                            'mc_source':lambda inj:inj.mchirp/(1.+calculate_redshift(inj.distance)),
                             'mc':lambda inj:inj.mchirp,
                             'mass1':lambda inj:inj.mass1,
                             'm1':lambda inj:inj.mass1,
@@ -799,6 +800,7 @@ class Posterior(object):
                             'phi_orb': lambda inj: inj.coa_phase,
                             'dist':lambda inj:inj.distance,
                             'distance':lambda inj:inj.distance,
+                            'redshift':lambda inj:calculate_redshift(inj.distance),
                             'ra':self._inj_longitude,
                             'rightascension':self._inj_longitude,
                             'long':self._inj_longitude,
@@ -833,7 +835,15 @@ class Posterior(object):
                 self._posterior['m2']=PosteriorOneDPDF('m2',m2,injected_value=self._getinjpar('m2'),trigger_values=self._gettrigpar('m2'))
             except KeyError:
                 print 'Unable to deduce m1 and m2 from input columns'
-
+        if 'mc_source' in common_output_table_header:
+            try:
+                print 'Inferring detector frame masses from source frame and redshift'
+                z=self._posterior['redshift'].samples
+                mcs=self._posterior['mc_source'].samples
+                mc=mcs*(1.+z)
+                self._posterior['chirpmass']=PosteriorOneDPDF('chirpmass',mc,injected_value=self._getinjpar('mc'),trigger_values=self._gettrigpar('mc'))
+            except KeyError:
+                print 'Unable to mc from mc_source\n'
 
         logLFound=False
 
@@ -875,13 +885,18 @@ class Posterior(object):
       """
       injection=self._injection
       pos=self
-      # Generate component mass posterior samples (if they didnt exist already)
+      mc_source=False
       if 'mc' in pos.names:
           mchirp_name = 'mc'
       elif 'chirpmass' in pos.names:
           mchirp_name = 'chirpmass'
+      elif 'chirpmass_source' in pos.names:
+          mc_source=True
+          mchirp_name = 'chirpmass'
       else:
           mchirp_name = 'mchirp'
+      if mc_source is True:
+          pos.append_mapping('chirpmass',lambda m,z:m*(1.+z) ,('chirpmass_source','redshift'))
 
       if 'asym_massratio' in pos.names:
           q_name = 'asym_massratio'
@@ -996,8 +1011,8 @@ class Posterior(object):
           pos.append_mapping('chi_p', chi_precessing, ['a1', 'tilt1', 'm1', 'a2', 'tilt2', 'm2'])
 
 
-      # Calculate redshift from luminosity distance measurements
-      if('distance' in pos.names):
+      # Calculate redshift from luminosity distance measurements, if not already available
+      if('distance' in pos.names) and not ('redshift' in pos.names):
           pos.append_mapping('redshift', calculate_redshift, 'distance')
       elif('dist' in pos.names):
           pos.append_mapping('redshift', calculate_redshift, 'dist')
@@ -1013,7 +1028,8 @@ class Posterior(object):
       if ('mtotal' in pos.names) and ('redshift' in pos.names):
           pos.append_mapping('mtotal_source', source_mass, ['mtotal', 'redshift'])
 
-      if ('mc' in pos.names) and ('redshift' in pos.names):
+      if ('mc' in pos.names) and ('redshift' in pos.names)and (not ('mc_source' in pos.names)):
+          # Add mc_source only if not already produced by the engine
           pos.append_mapping('mc_source', source_mass, ['mc', 'redshift'])
 
       #Store signed spin magnitudes in separate parameters and make a1,a2 magnitudes
@@ -1053,8 +1069,8 @@ class Posterior(object):
       if ('m1' in pos.names and 'a1' in pos.names and 'tilt1' in pos.names) and ('m2' in pos.names and 'a2' in pos.names and 'tilt2' in pos.names):
           pos.append_mapping('chi_p', chi_precessing, ['m1', 'a1', 'tilt1', 'm2', 'a2', 'tilt2'])
 
-      # Calculate redshift from luminosity distance measurements
-      if('distance' in pos.names):
+      # Calculate redshift from luminosity distance measurements, if not already available
+      if('distance' in pos.names) and not ('redshift' in pos.names):
           pos.append_mapping('redshift', calculate_redshift, 'distance')
 
       # Calculate source mass parameters
@@ -5698,7 +5714,7 @@ class PEOutputParser(object):
                                      "time_mean", "time_maxl","sky_frame","psdscaleflag","logdeltaf","flow","f_ref",
                                      "lal_amporder","lal_pnorder","lal_approximant","tideo","spino","signalmodelflag",
                                      "temperature","nifo","nlocaltemps","ntemps","randomseed","samplerate","segmentlength","segmentstart",
-                                     "t0", "phase_maxl", "azimuth", "cosalpha"] + logParams + snrParams + splineParams
+                                     "t0", "phase_maxl", "azimuth", "cosalpha","sampleredshift"] + logParams + snrParams + splineParams
                         nonParamsIdxs = [header.index(name) for name in nonParams if name in header]
                         samps = np.array(lines).astype(float)
                         fixedIdxs = np.where(np.amin(samps,axis=0)-np.amax(samps,axis=0) == 0.0)[0]
diff --git a/lalinference/src/LALInference.c b/lalinference/src/LALInference.c
index d8566763e7..35a5e6c750 100644
--- a/lalinference/src/LALInference.c
+++ b/lalinference/src/LALInference.c
@@ -1293,6 +1293,8 @@ const char *LALInferenceTranslateInternalToExternalParamName(const char *inName)
     return "tilt1";
   } else if (!strcmp(inName, "tilt_spin2")) {
     return "tilt2";
+  } else if (!strcmp(inName, "chirpmass_source")) {
+    return "mc_source";
   } else if (!strcmp(inName, "chirpmass")) {
     return "mc";
   } else if (!strcmp(inName, "eta")) {
@@ -1325,6 +1327,8 @@ void LALInferenceTranslateExternalToInternalParamName(char *outName, const char
     strcpy(outName, "tilt_spin1");
   } else if (!strcmp(inName, "tilt2")) {
     strcpy(outName, "tilt_spin2");
+  } else if (!strcmp(inName, "mc_source")) {
+    strcpy(outName, "chirpmass_source");
   } else if (!strcmp(inName, "mc")) {
     strcpy(outName, "chirpmass");
   } else if (!strcmp(inName, "eta")) {
@@ -2138,7 +2142,9 @@ char *colNameToParamName(const char *colName) {
   else if (!strcmp(colName, "psi")) {
     retstr=XLALStringDuplicate("polarisation");
   }
-
+  else if (!strcmp(colName, "mc_source")) {
+    retstr=XLALStringDuplicate("chirpmass_source");
+  }
   else if (!strcmp(colName, "mc")) {
     retstr=XLALStringDuplicate("chirpmass");
   }
diff --git a/lalinference/src/LALInference.h b/lalinference/src/LALInference.h
index f3a52fcf03..1503f12a16 100644
--- a/lalinference/src/LALInference.h
+++ b/lalinference/src/LALInference.h
@@ -87,6 +87,7 @@
 #include <gsl/gsl_statistics.h>
 #include <gsl/gsl_complex_math.h>
 #include <sys/time.h>
+#include <lal/LALCosmologyCalculator.h>
 
 /*LIB imports*/
 #include <lal/LALInferenceBurstRoutines.h>
@@ -466,6 +467,7 @@ typedef struct tagLALInferenceModel
   REAL8FFTPlan                *timeToFreqFFTPlan, *freqToTimeFFTPlan; /** Pre-calculated FFT plans for forward and reverse FFTs */
   REAL8Window                 *window;        /** A window */
   REAL8                        padding; /** The padding of the above window */
+  LALCosmologicalParameters   *omega;
   struct tagLALInferenceROQModel *roq; /** ROQ data */
   int roq_flag;               /** Is ROQ enabled */
   LALSimNeutronStarFamily     *eos_fam; /** Neutron Star equation of state family */
diff --git a/lalinference/src/LALInferenceInitCBC.c b/lalinference/src/LALInferenceInitCBC.c
index f889cb68f2..995452ae43 100644
--- a/lalinference/src/LALInferenceInitCBC.c
+++ b/lalinference/src/LALInferenceInitCBC.c
@@ -727,6 +727,13 @@ LALInferenceModel *LALInferenceInitCBCModel(LALInferenceRunState *state) {
     --- Template Arguments -----------------------\n\
     ----------------------------------------------\n\
     (--use-eta)            Jump in symmetric mass ratio eta, instead of q=m1/m2 (m1>m2)\n\
+    (--use-redshift)       Jump in redshift instead of logdistance. Use source masses. \n\
+    (--cosmology-h0)       (with use-cosmology) Set reduced Hubble constant (0.7)\n\
+    (--cosmology-omega-l)       (with use-cosmology) Set omega lambda (0.7)\n\
+    (--cosmology-omega-m)       (with use-cosmology) Set omega matter (0.3)\n\
+    (--cosmology-w0)       (with use-cosmology) Set w0 (-1.0)\n\
+    (--cosmology-w1)       (with use-cosmology) Set w1 (0/0)\n\
+    (--cosmology-w2)       (with use-cosmology) Set w2 (0.0)\n\
     (--approx)             Specify a template approximant and phase order to use\n\
                          (default TaylorF2threePointFivePN). Available approximants:\n\
                          default modeldomain=\"time\": GeneratePPN, TaylorT1, TaylorT2,\n\
@@ -880,6 +887,15 @@ LALInferenceModel *LALInferenceInitCBCModel(LALInferenceRunState *state) {
   gsl_rng *GSLrandom=state->GSLrandom;
   REAL8 endtime=0.0, timeParam=0.0;
   REAL8 timeMin=endtime-dt,timeMax=endtime+dt;
+  REAL8 z_min=1e-7;
+  REAL8 z_max=.3729; // ~ 2Gp
+  REAL8 reduced_h0=0.7;
+  REAL8 omega_l=0.7;
+  REAL8 omega_m=0.3;
+  REAL8 w0=-1.0;
+  REAL8 w1=0.0;
+  REAL8 w2=0.0;
+  LALCosmologicalParameters *omega=NULL;
   REAL8 zero=0.0; /* just a number that will be overwritten anyway*/
 
   /* Over-ride prior bounds if analytic test */
@@ -922,7 +938,23 @@ LALInferenceModel *LALInferenceInitCBCModel(LALInferenceRunState *state) {
       while(i<event) {i++; injTable=injTable->next;} /* select event */
     }
   }
-
+  if ((ppt=LALInferenceGetProcParamVal(commandLine,"--use-redshift"))){
+    fprintf(stdout,"Sampling in redshift!\n");  
+    /* Read in the cosmology the user wants to use and the prior range for the redshift. 
+     * Default cosmology is Plack 2015 */
+    if((ppt=LALInferenceGetProcParamVal(commandLine,"--z-max"))) z_max=atof(ppt->value);
+    if((ppt=LALInferenceGetProcParamVal(commandLine,"--z-min"))) z_min=atof(ppt->value);
+    if ((ppt=LALInferenceGetProcParamVal(commandLine,"--cosmology-h0"))) reduced_h0=atof(ppt->value);
+    if ((ppt=LALInferenceGetProcParamVal(commandLine,"--cosmology-omega-l"))) omega_l=atof(ppt->value);
+    if ((ppt=LALInferenceGetProcParamVal(commandLine,"--cosmology-omega-m"))) omega_m=atof(ppt->value);
+    if ((ppt=LALInferenceGetProcParamVal(commandLine,"--cosmology-w0"))) w0=atof(ppt->value);
+    if ((ppt=LALInferenceGetProcParamVal(commandLine,"--cosmology-w1"))) w1=atof(ppt->value);
+    if ((ppt=LALInferenceGetProcParamVal(commandLine,"--cosmology-w2"))) w2=atof(ppt->value);
+    fprintf(stdout,"Working with cosmology: h= %.1f, omega_l=%.1f, omega_m=%.1f, w0=%.1f , w1=%.1f, w2=%.1f\n",reduced_h0,omega_l,omega_m,w0,w1,w2);
+    
+    omega = XLALCreateCosmologicalParameters(reduced_h0,omega_m,omega_l,w0,w1,w2);
+    model->omega=omega;
+  }
   /* See if there are any parameters pinned to injection values */
   if((ppt=LALInferenceGetProcParamVal(commandLine,"--pinparams"))){
     char *pinned_params=ppt->value;
@@ -931,7 +963,7 @@ LALInferenceModel *LALInferenceInitCBCModel(LALInferenceRunState *state) {
     char **strings=NULL;
     UINT4 N;
     LALInferenceParseCharacterOptionString(pinned_params,&strings,&N);
-    LALInferenceInjectionToVariables(injTable,&tempParams);
+    LALInferenceInjectionToVariables(injTable,&tempParams,model->omega);
     LALInferenceVariableItem *node=NULL;
     while(N>0){
       N--;
@@ -1266,30 +1298,41 @@ LALInferenceModel *LALInferenceInitCBCModel(LALInferenceRunState *state) {
      * That function will then take care of setting startval to a random value between min and max, or read a value from command line (with --parname VALUE).
      * The user can fix the param to a given value with --fix-parname --parname VALUE
      * */
-    LALInferenceRegisterUniformVariableREAL8(state, model->params, "chirpmass", zero, mcMin, mcMax, LALINFERENCE_PARAM_LINEAR);
-    /* Check if running with symmetric (eta) or asymmetric (q) mass ratio.*/
-    ppt=LALInferenceGetProcParamVal(commandLine,"--use-eta");
-    if(ppt)
-      LALInferenceRegisterUniformVariableREAL8(state, model->params, "eta", zero, etaMin, etaMax, LALINFERENCE_PARAM_LINEAR);
-    else
-      LALInferenceRegisterUniformVariableREAL8(state, model->params, "q", zero, qMin, qMax, LALINFERENCE_PARAM_LINEAR);
-
-
     if(!LALInferenceGetProcParamVal(commandLine,"--margphi") && !LALInferenceGetProcParamVal(commandLine, "--margtimephi")){
       LALInferenceRegisterUniformVariableREAL8(state, model->params, "phase", zero, phiMin, phiMax, LALINFERENCE_PARAM_CIRCULAR);
     }
 
-  /* Check for distance prior for use if the user samples in logdistance */
-  if((ppt=LALInferenceGetProcParamVal(commandLine,"--distance-max"))) Dmax=atof(ppt->value);
-  if((ppt=LALInferenceGetProcParamVal(commandLine,"--distance-min"))) Dmin=atof(ppt->value);
-  LALInferenceParamVaryType distanceVary = LALINFERENCE_PARAM_LINEAR;
-  if((ppt=LALInferenceGetProcParamVal(commandLine,"--fix-distance")))
-  {
-    Dinitial=atof(ppt->value);
-    distanceVary = LALINFERENCE_PARAM_FIXED;
+  UINT4 sampleredshift=0;
+  if ((ppt=LALInferenceGetProcParamVal(commandLine,"--use-redshift"))){
+    /* If desired, sample using redshift instead of (log)distance, hence having a truly uniform in comoving volume prior. */
+    sampleredshift=1;
+    LALInferenceRegisterUniformVariableREAL8(state, model->params, "redshift", zero, z_min, z_max,LALINFERENCE_PARAM_LINEAR);
+    LALInferenceRegisterUniformVariableREAL8(state, model->params, "logdistance", zero, log(XLALLuminosityDistance(model->omega,z_min)),log(XLALLuminosityDistance(model->omega,z_max)),LALINFERENCE_PARAM_OUTPUT);
+    LALInferenceRegisterUniformVariableREAL8(state, model->params, "chirpmass_source", zero, mcMin, mcMax, LALINFERENCE_PARAM_LINEAR);
+  }
+  else{  
+    /* Check for distance prior for use if the user samples in logdistance */
+    if((ppt=LALInferenceGetProcParamVal(commandLine,"--distance-max"))) Dmax=atof(ppt->value);
+    if((ppt=LALInferenceGetProcParamVal(commandLine,"--distance-min"))) Dmin=atof(ppt->value);
+    LALInferenceParamVaryType distanceVary = LALINFERENCE_PARAM_LINEAR;
+    if((ppt=LALInferenceGetProcParamVal(commandLine,"--fix-distance")))
+    {
+      Dinitial=atof(ppt->value);
+      distanceVary = LALINFERENCE_PARAM_FIXED;
+    }
+    LALInferenceRegisterUniformVariableREAL8(state, model->params, "logdistance", log(Dinitial), log(Dmin), log(Dmax),distanceVary);
+    LALInferenceRegisterUniformVariableREAL8(state, model->params, "chirpmass", zero, mcMin, mcMax, LALINFERENCE_PARAM_LINEAR);
+    model->omega=NULL;
   }
-
-  LALInferenceRegisterUniformVariableREAL8(state, model->params, "logdistance", log(Dinitial), log(Dmin), log(Dmax), distanceVary);
+  /* Check if running with symmetric (eta) or asymmetric (q) mass ratio.*/
+  ppt=LALInferenceGetProcParamVal(commandLine,"--use-eta");
+  if(ppt)
+    LALInferenceRegisterUniformVariableREAL8(state, model->params, "eta", zero, etaMin, etaMax, LALINFERENCE_PARAM_LINEAR);
+  else
+    LALInferenceRegisterUniformVariableREAL8(state, model->params, "q", zero, qMin, qMax, LALINFERENCE_PARAM_LINEAR);
+    
+  LALInferenceAddVariable(model->params, "sampleredshift", &sampleredshift, LALINFERENCE_UINT4_t,LALINFERENCE_PARAM_FIXED);
+ 
   LALInferenceRegisterUniformVariableREAL8(state, model->params, "polarisation", zero, psiMin, psiMax, LALINFERENCE_PARAM_LINEAR);
   LALInferenceRegisterUniformVariableREAL8(state, model->params, "costheta_jn", zero, costhetaJNmin, costhetaJNmax,LALINFERENCE_PARAM_LINEAR);
 
diff --git a/lalinference/src/LALInferenceLikelihood.c b/lalinference/src/LALInferenceLikelihood.c
index aef53b9633..25a3463e5c 100644
--- a/lalinference/src/LALInferenceLikelihood.c
+++ b/lalinference/src/LALInferenceLikelihood.c
@@ -39,6 +39,7 @@
 #include <gsl/gsl_sf_erf.h>
 #include <gsl/gsl_complex_math.h>
 #include <lal/LALInferenceTemplate.h>
+#include <lal/LALCosmologyCalculator.h>
 
 #include "logaddexp.h"
 
@@ -291,7 +292,12 @@ REAL8 LALInferenceZeroLogLikelihood(LALInferenceVariables *currentParams,
       LALInferenceAddVariable(currentParams,"declination",&dec,LALINFERENCE_REAL8_t,LALINFERENCE_PARAM_OUTPUT);
       LALInferenceAddVariable(currentParams,"time",&GPSdouble,LALINFERENCE_REAL8_t,LALINFERENCE_PARAM_OUTPUT);
     }
-
+  if (LALInferenceCheckVariable(currentParams,"sampleredshift") && *(INT4 *)LALInferenceGetVariable(currentParams,"sampleredshift")==1){
+      // sampling in redshift, obtain distance here
+      REAL8 redshift=*(REAL8*) LALInferenceGetVariable(currentParams, "redshift");
+      REAL8 dl=log(XLALLuminosityDistance(model->omega,redshift));
+      LALInferenceAddVariable(currentParams,"logdistance",&dl,LALINFERENCE_REAL8_t,LALINFERENCE_PARAM_OUTPUT);
+  }
   REAL8 zero = 0.0;
   LALInferenceAddVariable(currentParams,"optimal_snr",&zero,LALINFERENCE_REAL8_t,LALINFERENCE_PARAM_OUTPUT);
   LALInferenceAddVariable(currentParams,"matched_filter_snr",&zero,LALINFERENCE_REAL8_t,LALINFERENCE_PARAM_OUTPUT);
@@ -482,6 +488,13 @@ static REAL8 LALInferenceFusedFreqDomainLogLikelihood(LALInferenceVariables *cur
       amp_prefactor = (*(REAL8*)LALInferenceGetVariable(currentParams,"hrss"));
     }
 
+    if (LALInferenceCheckVariable(currentParams,"sampleredshift") && *(INT4 *)LALInferenceGetVariable(currentParams,"sampleredshift")==1){
+      // sampling in redshift, obtain distance here
+      REAL8 redshift=*(REAL8*) LALInferenceGetVariable(currentParams, "redshift");
+      REAL8 dl=log(XLALLuminosityDistance(model->omega,redshift));
+      LALInferenceAddVariable(currentParams,"logdistance",&dl,LALINFERENCE_REAL8_t,LALINFERENCE_PARAM_OUTPUT);
+    }
+
     INT4 SKY_FRAME=0;
     if(LALInferenceCheckVariable(currentParams,"SKY_FRAME"))
       SKY_FRAME=*(INT4 *)LALInferenceGetVariable(currentParams,"SKY_FRAME");
diff --git a/lalinference/src/LALInferenceNestedSampler.c b/lalinference/src/LALInferenceNestedSampler.c
index d846029a1c..1b6bf3d59e 100644
--- a/lalinference/src/LALInferenceNestedSampler.c
+++ b/lalinference/src/LALInferenceNestedSampler.c
@@ -21,6 +21,11 @@
 #include <lal/LALInferencePrior.h>
 #include <lal/LALInferenceLikelihood.h>
 #include <lal/LALInferenceProposal.h>
+#include <lal/LALCosmologyCalculator.h>
+
+#ifdef HAVE_LIBLALXML
+#include <lal/LALInferenceXML.h>
+#endif
 #include <lal/LALInferenceHDF5.h>
 #include <lal/LALInferencePriorVolumes.h>
 
@@ -1445,6 +1450,16 @@ UINT4 LALInferenceMCMCSamplePrior(LALInferenceRunState *runState)
     }
     else {
         accepted=1;
+        
+        /*
+          if (LALInferenceCheckVariable(threadState->currentParams,"sampleredshift") && *(INT4 *)LALInferenceGetVariable(threadState->currentParams,"sampleredshift")==1){
+          // The proposal jumped using the redshift, we need to update the logdistance here, if we want to have it in the output file.
+         // Alternatively, we could skip this and only convert in postprocessing. //
+          REAL8 redshift=*(REAL8*) LALInferenceGetVariable(&proposedParams, "redshift");
+          REAL8 dl=log(XLALLuminosityDistance(threadState->model->omega,redshift));
+          LALInferenceAddVariable(&proposedParams,"logdistance",&dl,LALINFERENCE_REAL8_t,LALINFERENCE_PARAM_OUTPUT);
+       }*/
+        
         //printf("Accepted line %i\n",__LINE__);
         LALInferenceCopyVariables(&proposedParams,threadState->currentParams);
         LALInferenceSetVariable(threadState->currentParams,"logPrior",&logPriorNew);
diff --git a/lalinference/src/LALInferencePrior.c b/lalinference/src/LALInferencePrior.c
index a7d5894194..4d59acdf8e 100644
--- a/lalinference/src/LALInferencePrior.c
+++ b/lalinference/src/LALInferencePrior.c
@@ -28,7 +28,7 @@
 #include <gsl/gsl_errno.h>
 #include <gsl/gsl_roots.h>
 #include <lal/LALSimBurst.h>
-
+#include <lal/LALCosmologyCalculator.h>
 #include "logaddexp.h"
 
 #ifdef __GNUC__
@@ -97,8 +97,14 @@ void LALInferenceInitCBCPrior(LALInferenceRunState *runState)
                                 "uniform_distance", &uniform_distance,
                                 LALINFERENCE_INT4_t,
                                 LALINFERENCE_PARAM_OUTPUT);
-
-
+    INT4 cosmo_z=0;
+    if (LALInferenceGetProcParamVal(commandLine, "--use-redshift"))
+      cosmo_z = 1;    
+    LALInferenceAddVariable(runState->priorArgs,
+                                "redshift-prior-cosmo", &cosmo_z,
+                                LALINFERENCE_INT4_t,
+                                LALINFERENCE_PARAM_OUTPUT);
+                                
     /* Set up malmquist prior */
     INT4 malmquist = 0;
     if (LALInferenceGetProcParamVal(commandLine, "--malmquistprior")) {
@@ -470,7 +476,13 @@ REAL8 LALInferenceInspiralPrior(LALInferenceRunState *runState, LALInferenceVari
     logPrior+=log(*(REAL8 *)LALInferenceGetVariable(params,"flow"));
   }
 
-  if(LALInferenceCheckVariable(params,"logdistance"))
+  if(LALInferenceCheckVariable(priorParams,"redshift-prior-cosmo") && (*(INT4 *)LALInferenceGetVariable(priorParams,"redshift-prior-cosmo")==1))
+  {
+    REAL8 redshift=*(REAL8*) LALInferenceGetVariable(params, "redshift");
+    REAL8 tmp=XLALUniformComovingVolumeDensity(redshift,model->omega);
+    logPrior+=log(tmp);
+  }
+  else if(LALInferenceCheckVariable(params,"logdistance")) 
     if (!(LALInferenceCheckVariable(priorParams,"uniform_distance") && LALInferenceGetINT4Variable(priorParams,"uniform_distance")))
       logPrior+=3.0* *(REAL8 *)LALInferenceGetVariable(params,"logdistance");
     else
@@ -486,30 +498,49 @@ REAL8 LALInferenceInspiralPrior(LALInferenceRunState *runState, LALInferenceVari
   }
  
 
-  if(LALInferenceCheckVariable(params,"logmc")) {
-    mc=exp(*(REAL8 *)LALInferenceGetVariable(params,"logmc"));
-  } else if(LALInferenceCheckVariable(params,"chirpmass")) {
-    mc=(*(REAL8 *)LALInferenceGetVariable(params,"chirpmass"));
-  }
-
-  if(LALInferenceCheckVariable(params,"q")) {
-    q=*(REAL8 *)LALInferenceGetVariable(params,"q");
-    LALInferenceMcQ2Masses(mc,q,&m1,&m2);
-  } else if(LALInferenceCheckVariable(params,"eta")) {
-    eta=*(REAL8 *)LALInferenceGetVariable(params,"eta");
-    LALInferenceMcEta2Masses(mc,eta,&m1,&m2);
+  if( (LALInferenceCheckVariable(priorParams,"redshift-prior-cosmo") && (*(INT4 *)LALInferenceGetVariable(priorParams,"redshift-prior-cosmo")==1)))
+  {
+     /* If sampling in redshift, use the source frame masses to calculate the prior. Read in mc_source and q and covert.
+ *       * This assumes user is using q, not eta. Need to check potential other choiches. */
+     REAL8 mcs=0.0;
+     if(LALInferenceCheckVariable(params,"chirpmass_source")) {
+      if(LALInferenceCheckVariable(params,"q")){
+        mcs=(*(REAL8 *)LALInferenceGetVariable(params,"chirpmass_source"));
+        q=*(REAL8 *)LALInferenceGetVariable(params,"q");
+        LALInferenceMcQ2Masses(mcs,q,&m1,&m2);
+      }
+      else{
+        fprintf(stderr,"ERROR, missing source mc\n");
+        exit(1);
+      }
+        logPrior+=log(m1*m1/mcs); 
+     }
   }
+  else{
+    if(LALInferenceCheckVariable(params,"logmc")) {
+      mc=exp(*(REAL8 *)LALInferenceGetVariable(params,"logmc"));
+    } else if(LALInferenceCheckVariable(params,"chirpmass")) {
+      mc=(*(REAL8 *)LALInferenceGetVariable(params,"chirpmass"));
+    }
+    if(LALInferenceCheckVariable(params,"q")) {
+      q=*(REAL8 *)LALInferenceGetVariable(params,"q");
+      LALInferenceMcQ2Masses(mc,q,&m1,&m2);
+    } else if(LALInferenceCheckVariable(params,"eta")) {
+      eta=*(REAL8 *)LALInferenceGetVariable(params,"eta");
+      LALInferenceMcEta2Masses(mc,eta,&m1,&m2);
+    }
 
-  if(LALInferenceCheckVariable(params,"logmc")) {
-    if(LALInferenceCheckVariable(params,"q"))
-      logPrior+=log(m1*m1);
-    else
-      logPrior+=log(((m1+m2)*(m1+m2)*(m1+m2))/(m1-m2));
-  } else if(LALInferenceCheckVariable(params,"chirpmass")) {
-    if(LALInferenceCheckVariable(params,"q"))
-      logPrior+=log(m1*m1/mc);
-    else
-      logPrior+=log(((m1+m2)*(m1+m2))/((m1-m2)*pow(eta,3.0/5.0)));
+    if(LALInferenceCheckVariable(params,"logmc")) {
+      if(LALInferenceCheckVariable(params,"q"))
+        logPrior+=log(m1*m1);
+      else
+        logPrior+=log(((m1+m2)*(m1+m2)*(m1+m2))/(m1-m2));
+    } else if(LALInferenceCheckVariable(params,"chirpmass")) {
+      if(LALInferenceCheckVariable(params,"q"))
+        logPrior+=log(m1*m1/mc);
+      else
+        logPrior+=log(((m1+m2)*(m1+m2))/((m1-m2)*pow(eta,3.0/5.0)));
+    }
   }
 
   /* Check for individual mass priors */
diff --git a/lalinference/src/LALInferenceProposal.c b/lalinference/src/LALInferenceProposal.c
index 90bbf2bd19..53469f49a3 100644
--- a/lalinference/src/LALInferenceProposal.c
+++ b/lalinference/src/LALInferenceProposal.c
@@ -57,7 +57,8 @@
 
 typedef enum {
   USES_DISTANCE_VARIABLE,
-  USES_LOG_DISTANCE_VARIABLE
+  USES_LOG_DISTANCE_VARIABLE,
+  USES_REDSHIFT_VARIABLE
 } DistanceParam;
 
 const char *const cycleArrayName = "Proposal Cycle";
@@ -99,7 +100,7 @@ static const char *intrinsicNames[] = {"chirpmass", "q", "eta", "mass1", "mass2"
   "tilt_spin1", "tilt_spin2", "phi12", "phi_jl", "frequency", "quality", "duration","polar_angle", "phase", "polar_eccentricity","dchi0","dchi1","dchi2","dchi3","dchi4","dchi5","dchi5l","dchi6","dchi6l","dchi7","aPPE","alphaPPE","bPPE","betaPPE","betaStep","fStep","dxi1","dxi2","dxi3","dxi4","dxi5","dxi6","dalpha1","dalpha2","dalpha3","dalpha4","dalpha5","dbeta1","dbeta2","dbeta3","dsigma1","dsigma2","dsigma3","dsigma4",NULL};
 
 static const char *extrinsicNames[] = {"rightascension", "declination", "cosalpha", "azimuth", "polarisation", "distance",
-  "logdistance", "time", "costheta_jn", "t0", "theta","hrss", "loghrss", NULL};
+  "logdistance", "redshift", "time", "costheta_jn", "t0", "theta","hrss", "loghrss", NULL};
 
 static INT4 same_detector_location(LALDetector *d1, LALDetector *d2) {
     INT4 i;
@@ -303,6 +304,9 @@ LALInferenceVariables *LALInferenceParseProposalArgs(LALInferenceRunState *runSt
       distance=0;
 
     ProcessParamsTable *command_line = runState->commandLine;
+    if (LALInferenceGetProcParamVal(command_line, "--use-redshift"))
+      /* Disable distance jump while sampling in redshift*/
+      distance=0;
 
     INT4 verbose = 0;
     if (LALInferenceGetProcParamVal(command_line, "--verbose"))
@@ -698,7 +702,7 @@ REAL8 LALInferenceSingleProposal(LALInferenceThreadState *thread,
             sigma = 0.02;
         } else if (!strcmp(param->name, "q")) {
             sigma = 0.08;
-        } else if (!strcmp(param->name, "chirpmass")) {
+        } else if (!strcmp(param->name, "chirpmass")|| !strcmp(param->name, "chirpmass_source")) {
             sigma = 1.0;
         } else if (!strcmp(param->name, "time")) {
             sigma = 0.02;
@@ -708,6 +712,8 @@ REAL8 LALInferenceSingleProposal(LALInferenceThreadState *thread,
             sigma = 0.6;
         } else if (!strcmp(param->name, "distance")) {
             sigma = 10.0;
+        } else if (!strcmp(param->name, "redshift")) {
+            sigma = 0.04;
         } else if (!strcmp(param->name, "declination")) {
             sigma = 0.3;
 		} else if (!strcmp(param->name, "azimuth")) {
diff --git a/lalinference/src/LALInferenceReadData.c b/lalinference/src/LALInferenceReadData.c
index 37929c0b60..59612bec5e 100644
--- a/lalinference/src/LALInferenceReadData.c
+++ b/lalinference/src/LALInferenceReadData.c
@@ -78,6 +78,7 @@
 #include <lal/LALInferenceInit.h>
 #include <lal/LALSimNoise.h>
 #include <LALInferenceRemoveLines.h>
+#include <lal/LALCosmologyCalculator.h>
 /* LIB deps */
 #include <lal/LALInferenceBurstRoutines.h>
 #include <lal/LIGOLwXMLBurstRead.h>
diff --git a/lalinference/src/LALInferenceReadData.h b/lalinference/src/LALInferenceReadData.h
index b0cc74f20b..e46b2ce49b 100644
--- a/lalinference/src/LALInferenceReadData.h
+++ b/lalinference/src/LALInferenceReadData.h
@@ -60,8 +60,7 @@ void LALInferenceSetupROQmodel(LALInferenceModel *model, ProcessParamsTable *com
  * \brief Fills the variable in vars with the injection values from theEventTable. Destroys contents of
  * vars. vars cannot be NULL. Resulting variables are LALINFERENCE_PARAM_FIXED.
  */
-void LALInferenceInjectionToVariables(SimInspiralTable *theEventTable, LALInferenceVariables *vars);
-
+void LALInferenceInjectionToVariables(SimInspiralTable *theEventTable, LALInferenceVariables *vars,LALCosmologicalParameters *omega);
 /**
  * \brief Function to output a sample with logL values etc for the injection, if one is made.
  * Requires --inj, --outfile and optionally --event (if not 0).
diff --git a/lalinference/src/LALInferenceTemplate.c b/lalinference/src/LALInferenceTemplate.c
index 376b0086fb..567102bbd7 100644
--- a/lalinference/src/LALInferenceTemplate.c
+++ b/lalinference/src/LALInferenceTemplate.c
@@ -274,11 +274,29 @@ void LALInferenceROQWrapperForXLALSimInspiralChooseFDWaveformSequence(LALInferen
 	mc2masses(mc, eta, &m1, &m2);
       }
     }
-  else if((m1_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass1")) && (m2_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass2")))
+  else if((LALInferenceCheckVariable(model->params, "mass1")) && (LALInferenceCheckVariable(model->params, "mass2")))
     {
+      m1_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass1");
+      m2_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass2");
       m1=*m1_p;
       m2=*m2_p;
     }
+  else if(LALInferenceCheckVariable(model->params,"chirpmass_source"))
+    {
+      /* We are sampling in redshift. The masses stored in model-> params are understood as source frame masses. Convert to detector frame masses here, before calling the WF generator */
+      mc  = *(REAL8*) LALInferenceGetVariable(model->params, "chirpmass_source");
+      if (LALInferenceCheckVariable(model->params,"q")) {
+        REAL8 q = *(REAL8 *)LALInferenceGetVariable(model->params,"q");
+        q2masses(mc, q, &m1, &m2);
+      } else {
+        REAL8 eta = *(REAL8*) LALInferenceGetVariable(model->params, "eta");
+        mc2masses(mc, eta, &m1, &m2);
+      }
+      REAL8 redshift=*(REAL8*) LALInferenceGetVariable(model->params, "redshift");
+      m1*=(1.+redshift);
+      m2*=(1.+redshift);
+      mc*=(1.+redshift);
+  }
   else
     {
       fprintf(stderr,"No mass parameters found!");
@@ -698,11 +716,29 @@ void LALInferenceTemplateXLALSimInspiralChooseWaveform(LALInferenceModel *model)
 	mc2masses(mc, eta, &m1, &m2);
       }
     }
-  else if((m1_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass1")) && (m2_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass2")))
+  else if((LALInferenceCheckVariable(model->params, "mass1")) && (LALInferenceCheckVariable(model->params, "mass2")))
     {
+      m1_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass1");
+      m2_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass2");
       m1=*m1_p;
       m2=*m2_p;
     }
+  else if(LALInferenceCheckVariable(model->params,"chirpmass_source"))
+    {
+      /* We are sampling in redshift. The masses stored in model-> params are understood as source frame masses. Convert to detector frame masses here, before calling the WF generator */
+      mc  = *(REAL8*) LALInferenceGetVariable(model->params, "chirpmass_source");
+      if (LALInferenceCheckVariable(model->params,"q")) {
+        REAL8 q = *(REAL8 *)LALInferenceGetVariable(model->params,"q");
+        q2masses(mc, q, &m1, &m2);
+      } else {
+        REAL8 eta = *(REAL8*) LALInferenceGetVariable(model->params, "eta");
+        mc2masses(mc, eta, &m1, &m2);
+      }
+      REAL8 redshift=*(REAL8*) LALInferenceGetVariable(model->params, "redshift");
+      m1*=(1.+redshift);
+      m2*=(1.+redshift);
+      mc*=(1.+redshift);
+  }
   else
     {
       fprintf(stderr,"No mass parameters found!");
@@ -1250,11 +1286,29 @@ void LALInferenceTemplateXLALSimInspiralChooseWaveformPhaseInterpolated(LALInfer
             mc2masses(mc, eta, &m1, &m2);
         }
     }
-    else if((m1_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass1")) && (m2_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass2")))
+  else if((LALInferenceCheckVariable(model->params, "mass1")) && (LALInferenceCheckVariable(model->params, "mass2")))
     {
+      m1_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass1");
+      m2_p=(REAL8 *)LALInferenceGetVariable(model->params, "mass2");
         m1=*m1_p;
         m2=*m2_p;
     }
+  else if(LALInferenceCheckVariable(model->params,"chirpmass_source"))
+    {
+      /* We are sampling in redshift. The masses stored in model-> params are understood as source frame masses. Convert to detector frame masses here, before calling the WF generator */
+      mc  = *(REAL8*) LALInferenceGetVariable(model->params, "chirpmass_source");
+      if (LALInferenceCheckVariable(model->params,"q")) {
+        REAL8 q = *(REAL8 *)LALInferenceGetVariable(model->params,"q");
+        q2masses(mc, q, &m1, &m2);
+      } else {
+        REAL8 eta = *(REAL8*) LALInferenceGetVariable(model->params, "eta");
+        mc2masses(mc, eta, &m1, &m2);
+      }
+      REAL8 redshift=*(REAL8*) LALInferenceGetVariable(model->params, "redshift");
+      m1*=(1.+redshift);
+      m2*=(1.+redshift);
+      mc*=(1.+redshift);
+  }
     else
     {
         fprintf(stderr,"No mass parameters found!");
-- 
2.13.0

